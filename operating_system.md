# 操作系统
![操作系统知识图谱](https://user-gold-cdn.xitu.io/2017/5/22/9ec446cf01928b9a62f9d852690476bd?imageslim)

> [操作系统面试重难点总结](https://juejin.im/entry/592257b62f301e006b183b95)
>
> 操作系统历史：[真香警告：即使不学 OS 进阶，也请务必收藏好该文！](https://juejin.im/post/5cf6a3845188253b2441287e)
>
> 从程序执行将操作系统：[1、操作系统概述（操作系统笔记）](https://www.jianshu.com/p/c6f96dee1006)

## 进程与线程

​	按照操作系统中的描述。线程是 CPU 调度的最小单元，同时线程也是一种有限的资源。而进程相当于线程的“容器”，在 PC 和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程。

### 进程

​	当一个程序第一次启动的时候，Android 会启动一个 Linux 进程和一个主线程。

​	默认情况下， 同一应用的所有组件均在相同的进程中运行。如果我们需要控制某个组件所属的进程，则可在 AndroidManifest 文件中执行此操作。

​	组件运行在哪个进程中，是在 AndroidManifest 文件中进行设置的，activity、service、 receiver 和 provider 均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。我们可以设置此属性，使每个组件均在各自的进程中运行。

#### 优先级

Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以 及这些组件的状态，将每个进程放入 “重要性层次结构” 中。必要时，系统会首先消除重要性最低的进程，然后是重要性相对较高的进程，以此类推，以回收进程。

重要性层次结构一共有 5 级

1、前台进程 — Foreground process

2、可见进程 — Visible process

3、服务进程 — Service process

4、后台进程 — Background process

5、空进程 — Empty process

### 线程

线程在 Android 中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程的 作用是「运行四大组件以及处理它们和用户的交互」，而子线程的作用则是「执行耗时任务， 比如网络请求、I/O 操作等」，由于 Android 的特性，如果在主线程中执行耗时操作那么就会 导致程序无法及时地响应。因此耗时操作必须放在子线程中执行。

#### Android 中的线程形态

除了 Thread 本身以外，在 Android 中可以扮演线程角色的还有很多，比如 AsyncTask 和 IntentService，同时 HandlerThread 也是一种特殊的线程。

尽管 AsyncTask、IntentService 以及 HandlerThread 的「表现形式」都有别于传统的线程，但是它们的本质仍然是传统的线程。



### 死锁

- What? 

  2个或者2个以上的进程，由于竞争资源造成的阻塞现象，如果没有外力的作用，他们将无法推进下去

- 产生的4大条件

  1. 互斥条件

     一个资源每次只能被一个进程使用

  2. 不可剥夺条件

     进程已获得的资源，没有释放之前不能被剥夺

  3. 请求和保持条件

     一个进程因为请求资源而阻塞，对于已经获取的资源保持不放

  4. 环路等待条件

     多个进程之间形成循环等待资源的关系

- 产生的原因

  1. 系统资源不足
  2. 进程运行推进的顺序不合适
  3. 资源分配不当

- 预防

  破坏四大条件

  1. 破坏资源的互斥性，资源能同时使用
  2. 资源可剥夺
  3. 请求可不保持，进程阻塞时可以释放已获取的资源
  4. 进程之间不要形成循环等待资源的关系

- 避免 

  [银行家算法](http://www.sohu.com/a/231485540_164987)

  可用资源、已分配资源、待分配资源 判断此次分配资源不会处于危险状态，才分配资源

- 检测和解除

  破坏4大条件





## 进程管理和CPU 调度

### linux的进程调度算法

- 背景

  为了提高**CPU利用率（CPU utilization）**

  - CPU中有READY信号,当收到I/O送来的信号后才会进行读写操作。
  - I/O操作不消耗CPU，而是让CPU闲置了，浪费CPU，因为I/O设备相对于CPU来说速度很慢,CPU要花大部分时间来等待I/O处理数据。

- 分类

  1. **先来先服务调度算法FCFS：**既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；

  2. **短作业优先调度算法SJF：**作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；

  3. **高相应比算法HRN：**响应比=(等待时间+要求服务时间)/要求服务时间；

  4. **时间片轮转调度RR：**按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;

  5. **多级反馈队列调度算法：**目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。





## 文件系统





## 内存管理

>  内存管理主要包括虚地址、地址变换、内存分配和回收、内存扩充、内存共享和保护等功能。 

###  **连续分配存储管理方式**

连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式。

#### 2.1 单一连续存储管理

- 介绍

  ​	在这种管理方式中，内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是，最简单，适用于单用户、单任务的操作系统

- 缺点

  ​	对要求内存空间少的程序，造成内存浪费。程序全部装入，使得很少使用的程序部分也占用—定数量的内存

#### 2.2 分区式存储管理



### **页式存储管理**

- 优点

   1）没有外碎片，每个内碎片不超过页大比前面所讨论的几种管理方式的最大进步是，

   2）一个程序不必连续存放。

   3）便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。

- 缺点

  要求程序全部装入内存，没有足够的内存，程序就不能执行。



### 虚拟内存

​	基于局部性原理，**在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存**，就可以启动程序执行。在程序执行过程中，**当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序**。另一方面，操作系统将内存中**暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息**。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。

1. 多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性

2. 对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)

3. 虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上

   

### 三级页表机制

​	在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用**两级页表或者多级页表的方法**，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。

**进程页表**：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。

**物理页面表：**整个系统有一个物理页面表，描述物理内存空间的分配使用状况，其数据结构可**采用位示图和空闲页链表**。

**请求表：**整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换也可以结合到各进程的PCB(进程控制块)里

### 缺页机制

- 简介

​	缺页中断（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在[虚拟](https://baike.baidu.com/item/虚拟)[地址空间](https://baike.baidu.com/item/地址空间)中，但是目前并未被加载在[物理内存](https://baike.baidu.com/item/物理内存)中的一个[分页](https://baike.baidu.com/item/分页)时，由[中央处理器](https://baike.baidu.com/item/中央处理器)的内存管理单元所发出的[中断](https://baike.baidu.com/item/中断)。

​	缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤： 
　　1. 保护CPU现场 
　　2. 分析中断原因 
　　3. 转入缺页中断处理程序进行处理 
　　4. 恢复CPU现场，继续执行 

- 算法

  FIFO、LRU



### 进程内存区域

![img](https://images2015.cnblogs.com/blog/1045927/201705/1045927-20170519160410322-545934477.png)

Linux进程的虚拟内存区域分为：代码区、只读常量区、全局区、BSS段、堆区、栈区

代码区：存储功能代码，函数名所在的区域

只读常量区：存放字符串常量，以及const修饰的全局变量

全局区/数据区：存放已经初始化的全局变量和已经初始化用static修饰的局部变量

BSS段：存放没有初始化的全局变量和未初始化静态局部变量，该区域会在main函数执行前进行自动清零

堆区：使用malloc/new free/delete函数处理的内存，该区域的内存需要程序员手动申请和释放

栈区：存放局部变量（包括函数的形参），const修饰的局部变量以及块变量，该区域的内存由操作系统负责分配和回收，程序员尽管放心使用

注意：栈区和堆区之间并没有严格分割线，可以进行微调，并且堆区分配一般从低地址到高地址分配，而栈区分配一般从高地址到低地址分配



## 系统调用

### epoll pipe

|      | select               | poll | epoll        |
| ---- | -------------------- | ---- | ------------ |
|      | 轮训遍历，只支持1024 |      | 管道通知回调 |
|      |                      |      |              |
|      |                      |      |              |







### elf hook

- 简介 

  ​	ELF（Executable and Linkable Format）是一种行业标准的二进制数据封装格式，主要用于封装可执行文件、动态库、object 文件和 core dumps 文件。

- 参考

  [Android Native Hook技术路线概述](https://gtoad.github.io/2018/07/05/Android-Native-Hook/)





### brk()、mmap、malloc()

**1、brk是将数据段(.data)的最高地址指针_edata往高地址推；**

**2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存**。

​     这两种方式分配的都是虚拟内存，没有分配物理内存**。**在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系

**3、malloc()分配内存**





### fork clone等

| 系统调用 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| fork     | fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容 |
| vfork    | vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行 |
| clone    | Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone |

​		




####  cow机制 

写时复制，当写修改变量的时候，才去

[Linux中fork，vfork和clone详解（区别与联系）](https://blog.csdn.net/gatieme/article/details/51417488)

- 参考: [COW奶牛！Copy On Write机制了解一下](https://juejin.im/post/5bd96bcaf265da396b72f855)

  



## io模型

### 常见问题

1. io操作占用cpu吗？

   I/O发展是经过一下一步步发展的

   1. CPU直接控制外围设备(硬盘磁带等), 在简单微处理器中常用
   2. 增加I/O模块, 将CPU与外围设备解耦, CPU只与I/O模块
     打交道. 只需定义好接口, CPU厂商和外围设备厂商就可以相互根据接口开发, 互不影响
   3. 增加中断方式, 还是经过I/O模块, 只不过I/O模块完成之后, 只需通知CPU即可, CPU在等待阶段完全可以去做其他事情, 提高CPU利用率.
   4. I/O模块增加DMA控制器. 之前的阶段是每次只传输一个字, 就通知CPU, 就发起一次中断, CPU放到寄存器中, 再放到内存中. 这样CPU就会被连续的中断打断, 不断切换进程, 上下文, 效率很低.
     DMA控制器类似于一个小的CPU, 有自己的寄存器(记录主存地址和取到的字的count等).
      CPU可以发起一个DMA请求, 传入读写操作类型, 相关I/O设备地址, 内存的起始地址, 要操作的字数.
     然后DMA就可以获取总线的控制权, 将一大块内存和外部I/O读入或写出.
     等操作完成后, 再通知CPU. 释放总线控制权.

   缺点是:

   系统总线也是一种资源, DMA操作期间, 当处理器需要访问总线时, 执行速度会变慢.

   但是总得来说, DMA是一种高效传输方式.

### 阻塞io

### 非阻塞io

### I/O多路复用

### 信号驱动I/O

### 异步I/O